# New-API (production-friendly) Docker Compose
#
# Build from local source (Dockerfile multi-stage builds web/dist + Go binary):
#   docker compose up -d --build
#
# Tip: Put secrets in a .env file (NOT committed), e.g.:
#   POSTGRES_PASSWORD=your_strong_password
#   SESSION_SECRET=your_random_string
#
# Then run:
#   docker compose up -d --build

version: "3.4"

services:
  new-api:
    build:
      context: .
      dockerfile: Dockerfile
    image: ${NEW_API_IMAGE:-new-api:local}
    container_name: new-api
    restart: always
    command: --log-dir /app/logs
    ports:
      - "${NEW_API_PORT:-3000}:3000"
    volumes:
      - ./data:/data
      - ./logs:/app/logs
    environment:
      TZ: ${TZ:-Asia/Shanghai}
      # Recommended to set explicitly in .env for production.
      SQL_DSN: ${SQL_DSN:-postgresql://root:${POSTGRES_PASSWORD:-PLEASE_CHANGE_ME}@postgres:5432/new-api}
      REDIS_CONN_STRING: ${REDIS_CONN_STRING:-redis://redis}
      ERROR_LOG_ENABLED: ${ERROR_LOG_ENABLED:-true}
      BATCH_UPDATE_ENABLED: ${BATCH_UPDATE_ENABLED:-true}
      # Set this for multi-node deployments.
      SESSION_SECRET: ${SESSION_SECRET:-}
    depends_on:
      - redis
      - postgres
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "wget -q -O - http://localhost:3000/api/status | grep -o '\"success\":\\s*true' || exit 1",
        ]
      interval: 30s
      timeout: 10s
      retries: 3
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

  redis:
    image: redis:7-alpine
    container_name: redis
    restart: always
    volumes:
      - redis_data:/data

  postgres:
    image: postgres:15
    container_name: postgres
    restart: always
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-root}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-PLEASE_CHANGE_ME}
      POSTGRES_DB: ${POSTGRES_DB:-new-api}
    volumes:
      - pg_data:/var/lib/postgresql/data

volumes:
  pg_data:
  redis_data:

